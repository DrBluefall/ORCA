//! `SeaORM` Entity.
//!
//! Originally generated by sea-orm-codegen 0.10.5. Further edits done by Doctor Bluefall.

use sea_orm::entity::prelude::*;
use sea_orm::sea_query;
use sea_orm::sea_query::{DynIden, SeaRc}; // this unbreaks the `sea_orm::Iden` derive. For some reason.

#[derive(Debug, Clone, PartialEq, Eq, EnumIter)]
pub enum AnarchyRank {
    CMinus,
    C,
    CPlus,
    BMinus,
    B,
    BPlus,
    AMinus,
    A,
    APlus,
    S,
    SPlus(u8),
}

#[derive(Debug, sea_orm::Iden)]
pub struct AnarchyRankEnum;

impl ActiveEnum for AnarchyRank {
    type Value = String;

    fn name() -> DynIden {
        SeaRc::new(AnarchyRankEnum)
    }

    fn to_value(&self) -> Self::Value {
        match self {
            AnarchyRank::CMinus => "C-".into(),
            AnarchyRank::C => "C".into(),
            AnarchyRank::CPlus => "C+".into(),
            AnarchyRank::BMinus => "B-".into(),
            AnarchyRank::B => "B".into(),
            AnarchyRank::BPlus => "B+".into(),
            AnarchyRank::AMinus => "A-".into(),
            AnarchyRank::A => "A".into(),
            AnarchyRank::APlus => "A+".into(),
            AnarchyRank::S => "S".into(),
            AnarchyRank::SPlus(int) => format!("S+{}", int),
        }
    }

    fn try_from_value(v: &Self::Value) -> Result<Self, DbErr> {
        let mut it = v.chars();

        match it.next().map(|x| x.to_ascii_uppercase()) {
            Some('C') => match it.next() {
                None => Ok(AnarchyRank::C),
                Some('+') => Ok(AnarchyRank::CPlus),
                Some('-') => Ok(AnarchyRank::CMinus),
                Some(_) => Err(DbErr::Type("Could not parse item into AnarchyRank".into())),
            },
            Some('B') => match it.next() {
                None => Ok(AnarchyRank::B),
                Some('+') => Ok(AnarchyRank::BPlus),
                Some('-') => Ok(AnarchyRank::BMinus),
                Some(_) => Err(DbErr::Type("Could not parse item into AnarchyRank".into())),
            },
            Some('A') => match it.next() {
                None => Ok(AnarchyRank::A),
                Some('+') => Ok(AnarchyRank::APlus),
                Some('-') => Ok(AnarchyRank::AMinus),
                Some(_) => Err(DbErr::Type("Could not parse item into AnarchyRank".into())),
            },
            Some('S') => match it.next() {
                None => Ok(AnarchyRank::S),
                Some('+') => {
                    // Collect the remaining items into a string
                    // This should be the integer prefixing S+.
                    let int = it.collect::<String>();
                    match u8::from_str_radix(&int, 10) {
                        Ok(i) => Ok(AnarchyRank::SPlus(i)),
                        Err(e) => Err(DbErr::Type(e.to_string())),
                    }
                }
                Some(_) => Err(DbErr::Type("Could not parse item into AnarchyRank".into())),
            },
            None | Some(_) => Err(DbErr::Type("Could not parse item into AnarchyRank".into())),
        }
    }

    fn db_type() -> sea_orm::ColumnDef {
        ColumnType::String(Some(4)).def()
    }
}

// The following section is copied from the sea-orm repository, with edits to
// actually make the previous implementation of `AnarchyRank` actually work.
//
// Normally this code would be generated automatically by
// #[derive(sea_orm::DeriveActiveEnum)], but since we're not using that, the
// code has to be... "manually" written.

#[allow(clippy::from_over_into)]
impl Into<sea_orm::sea_query::Value> for AnarchyRank {
    fn into(self) -> sea_orm::sea_query::Value {
        <Self as sea_orm::ActiveEnum>::to_value(&self).into()
    }
}

impl sea_orm::TryGetable for AnarchyRank {
    fn try_get(
        res: &sea_orm::QueryResult,
        pre: &str,
        col: &str,
    ) -> std::result::Result<Self, sea_orm::TryGetError> {
        let value =
            <<Self as sea_orm::ActiveEnum>::Value as sea_orm::TryGetable>::try_get(res, pre, col)?;
        <Self as sea_orm::ActiveEnum>::try_from_value(&value).map_err(sea_orm::TryGetError::DbErr)
    }
}

impl sea_orm::sea_query::ValueType for AnarchyRank {
    fn try_from(
        v: sea_orm::sea_query::Value,
    ) -> std::result::Result<Self, sea_orm::sea_query::ValueTypeErr> {
        let value =
            <<Self as sea_orm::ActiveEnum>::Value as sea_orm::sea_query::ValueType>::try_from(v)?;
        <Self as sea_orm::ActiveEnum>::try_from_value(&value)
            .map_err(|_| sea_orm::sea_query::ValueTypeErr)
    }

    fn type_name() -> String {
        <<Self as sea_orm::ActiveEnum>::Value as sea_orm::sea_query::ValueType>::type_name()
    }

    fn array_type() -> sea_orm::sea_query::ArrayType {
        <<Self as sea_orm::ActiveEnum>::Value as sea_orm::sea_query::ValueType>::array_type()
    }

    fn column_type() -> sea_orm::sea_query::ColumnType {
        <Self as sea_orm::ActiveEnum>::db_type()
            .get_column_type()
            .to_owned()
            .into()
    }
}

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(table_name = "s3_profile")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: u64,
    pub ign: String,
    pub discriminator: String,
    pub level: u16,
    pub turf_inked: u32,
    pub total_wins: u16,
    pub anarchy_rank_best: AnarchyRank,
    pub anarchy_rank_current: AnarchyRank,
    pub friend_code: String,
    pub fclink_token: Option<String>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_one = "super::xbattle_stats::Entity")]
    XBattleStats,
}

impl Related<super::xbattle_stats::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::XBattleStats.def()
    }
}


impl ActiveModelBehavior for ActiveModel {}
