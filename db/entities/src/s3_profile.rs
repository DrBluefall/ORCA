//! `SeaORM` Entity.
//!
//! Originally generated by sea-orm-codegen 0.10.5. Further edits done by Doctor Bluefall.

use sea_orm::entity::prelude::*;
use sea_orm::sea_query;
use sea_orm::sea_query::{DynIden, SeaRc}; // this unbreaks the `sea_orm::Iden` derive. For some reason.
use serde::de::Visitor;

#[derive(Debug, Clone, PartialEq, Eq, EnumIter)]
pub enum AnarchyRank {
    CMinus,
    C,
    CPlus,
    BMinus,
    B,
    BPlus,
    AMinus,
    A,
    APlus,
    S,
    SPlus(u8),
}

impl std::fmt::Display for AnarchyRank {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {

        match self {
            AnarchyRank::CMinus => write!(f, "C-"),
            AnarchyRank::C => write!(f,"C"),
            AnarchyRank::CPlus => write!(f,"C+"),
            AnarchyRank::BMinus => write!(f,"B-"),
            AnarchyRank::B => write!(f,"B"),
            AnarchyRank::BPlus => write!(f,"B+"),
            AnarchyRank::AMinus => write!(f,"A-"),
            AnarchyRank::A => write!(f,"A"),
            AnarchyRank::APlus => write!(f,"A+"),
            AnarchyRank::S => write!(f,"S"),
            AnarchyRank::SPlus(int) => write!(f, "S+{}", if *int > 50 { &50 } else { int }),
        }
    }
}

impl std::str::FromStr for AnarchyRank {
    type Err = DbErr;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut it = s.chars();

        match it.next().map(|x| x.to_ascii_uppercase()) {
            Some('C') => match it.next() {
                None => Ok(AnarchyRank::C),
                Some('+') => Ok(AnarchyRank::CPlus),
                Some('-') => Ok(AnarchyRank::CMinus),
                Some(_) => Err(DbErr::Type("Could not parse item into AnarchyRank".into())),
            },
            Some('B') => match it.next() {
                None => Ok(AnarchyRank::B),
                Some('+') => Ok(AnarchyRank::BPlus),
                Some('-') => Ok(AnarchyRank::BMinus),
                Some(_) => Err(DbErr::Type("Could not parse item into AnarchyRank".into())),
            },
            Some('A') => match it.next() {
                None => Ok(AnarchyRank::A),
                Some('+') => Ok(AnarchyRank::APlus),
                Some('-') => Ok(AnarchyRank::AMinus),
                Some(_) => Err(DbErr::Type("Could not parse item into AnarchyRank".into())),
            },
            Some('S') => match it.next() {
                None => Ok(AnarchyRank::S),
                Some('+') => {
                    // Collect the remaining items into a string
                    // This should be the integer prefixing S+.
                    let int = it.collect::<String>();
                    match u8::from_str_radix(&int, 10) {
                        Ok(i) => Ok(AnarchyRank::SPlus(i)),
                        Err(e) => Err(DbErr::Type(e.to_string())),
                    }
                }
                Some(_) => Err(DbErr::Type("Could not parse item into AnarchyRank".into())),
            },
            None | Some(_) => Err(DbErr::Type("Could not parse item into AnarchyRank".into())),
        }
    }
}

#[derive(Debug, sea_orm::Iden)]
pub struct AnarchyRankEnum;

struct AnarchyRankVisitor;

impl<'de> serde::Deserialize<'de> for AnarchyRank {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de> {
        deserializer.deserialize_str(AnarchyRankVisitor)
    }
}

impl<'v> Visitor<'v> for AnarchyRankVisitor {
    type Value = AnarchyRank;

    fn expecting(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "A rank in valid format (/[CBA][-+]?|S(\\+\\d{{1,2}})?/)")
    }
    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
    where
        E: serde::de::Error, {
        v.parse().map_err(|e| E::custom(format!("{}", e)))
    }

}


impl serde::Serialize for AnarchyRank {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

impl ActiveEnum for AnarchyRank {
    type Value = String;

    fn name() -> DynIden {
        SeaRc::new(AnarchyRankEnum)
    }

    fn to_value(&self) -> Self::Value {
        self.to_string()
    }

    fn try_from_value(v: &Self::Value) -> Result<Self, DbErr> {
        v.parse()
    }

    fn db_type() -> sea_orm::ColumnDef {
        ColumnType::String(Some(4)).def()
    }
}

// The following section is copied from the sea-orm repository, with edits to
// actually make the previous implementation of `AnarchyRank` actually work.
//
// Normally this code would be generated automatically by
// #[derive(sea_orm::DeriveActiveEnum)], but since we're not using that, the
// code has to be... "manually" written.

#[allow(clippy::from_over_into)]
impl Into<sea_orm::sea_query::Value> for AnarchyRank {
    fn into(self) -> sea_orm::sea_query::Value {
        <Self as sea_orm::ActiveEnum>::to_value(&self).into()
    }
}

impl sea_orm::TryGetable for AnarchyRank {
    fn try_get(
        res: &sea_orm::QueryResult,
        pre: &str,
        col: &str,
    ) -> std::result::Result<Self, sea_orm::TryGetError> {
        let value =
            <<Self as sea_orm::ActiveEnum>::Value as sea_orm::TryGetable>::try_get(res, pre, col)?;
        <Self as sea_orm::ActiveEnum>::try_from_value(&value).map_err(sea_orm::TryGetError::DbErr)
    }
}

impl sea_orm::sea_query::ValueType for AnarchyRank {
    fn try_from(
        v: sea_orm::sea_query::Value,
    ) -> std::result::Result<Self, sea_orm::sea_query::ValueTypeErr> {
        let value =
            <<Self as sea_orm::ActiveEnum>::Value as sea_orm::sea_query::ValueType>::try_from(v)?;
        <Self as sea_orm::ActiveEnum>::try_from_value(&value)
            .map_err(|_| sea_orm::sea_query::ValueTypeErr)
    }

    fn type_name() -> String {
        <<Self as sea_orm::ActiveEnum>::Value as sea_orm::sea_query::ValueType>::type_name()
    }

    fn array_type() -> sea_orm::sea_query::ArrayType {
        <<Self as sea_orm::ActiveEnum>::Value as sea_orm::sea_query::ValueType>::array_type()
    }

    fn column_type() -> sea_orm::sea_query::ColumnType {
        <Self as sea_orm::ActiveEnum>::db_type()
            .get_column_type()
            .to_owned()
            .into()
    }
}

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, serde::Serialize, serde::Deserialize)]
#[sea_orm(table_name = "s3_profile")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: u64,
    pub ign: String,
    pub discriminator: String,
    pub level: u16,
    pub turf_inked: u32,
    pub total_wins: u16,
    pub anarchy_rank_best: AnarchyRank,
    pub anarchy_rank_current: AnarchyRank,
    pub friend_code: String,
    pub fclink_token: Option<String>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_one = "super::xbattle_stats::Entity")]
    XBattleStats,
}

impl Related<super::xbattle_stats::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::XBattleStats.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
